# Memtest with valgrind. In FLSSS.Rcheck do:
R -d valgrind --vanilla < FLSSS-Ex.R


R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "FLSSS"
> source(file.path(R.home("share"), "R", "examples-header.R"))
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x55F4E77: __wcsnlen_avx2 (strlen-avx2.S:261)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDB196: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C408: internal_utf8_loop (loop.c:298)
==3674==    by 0x548C408: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDB196: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C411: internal_utf8_loop (loop.c:303)
==3674==    by 0x548C411: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDB196: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C458: internal_utf8_loop (loop.c:298)
==3674==    by 0x548C458: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDB196: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==
> options(warn = 1)
> library('FLSSS')
>
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("FLSSS")
> ### * FLSSS
>
> flush(stderr()); flush(stdout())
>
> ### Name: FLSSS
> ### Title: One-dimensional Subset Sum given error threshold
> ### Aliases: FLSSS
>
> ### ** Examples
>
> # =====================================================================================
> # Example I: play random numbers.
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 393963 21.1     750400 40.1   486257 26.0
Vcells 710656  5.5    1308461 10.0  1023713  7.9
> subsetSize = 200L
> supersetSize = 1000L
> superset = 10000 * sort(rnorm(supersetSize) ^ 3 + 2 * runif(supersetSize) ^ 2 +
+            3 * rgamma(supersetSize, 5, 1) + 4)
> subsetSum = runif(1, sum(superset[1L : subsetSize]), sum(superset[(supersetSize -
+             subsetSize + 1L) : supersetSize]))
> subsetSumError = 1e-3
>
>
> # Mine 3 subsets
> rst1 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                     ME = subsetSumError, solutionNeed = 3, tlimit = 4)
>
>
> # Mine 3 subsets via solving the conjugate problem
> rst2 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                     ME = subsetSumError, solutionNeed = 3, tlimit = 4,
+                     viaConjugate = TRUE)
>
>
> # Verify uniqueness
> cat("rst1 number of solutions =",
+     length(unique(lapply(rst1, function(x) sort(x)))), "\n")
rst1 number of solutions = 3
> cat("rst2 number of solutions =",
+     length(unique(lapply(rst2, function(x) sort(x)))), "\n")
rst2 number of solutions = 3
>
>
> # Verify solutions
> if(length(rst1) > 0)
+   all(unlist(lapply(rst1, function(x)
+     abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
> if(length(rst2) > 0)
+   all(unlist(lapply(rst2, function(x)
+     abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
>
>
> # Mine 3 subsets in bounded solution space.
> # Make up the lower and upper bounds for the solution space:
> tmp = sort(sample(1L : supersetSize, subsetSize))
> tmp2 = sort(sample(1L : supersetSize, subsetSize))
> lowerBounds = pmin(tmp, tmp2)
> upperBounds = pmax(tmp, tmp2)
> rm(tmp, tmp2)
>
>
> # 'FLSSS()' does not work if there are elements not under the hood of
> # lowerBounds + upperBounds. Exclude those elements:
> remainIndex = unique(unlist(apply(cbind(lowerBounds, upperBounds), 1,
+   function(x) x[1] : x[2])))
> lowerBounds = match(lowerBounds, remainIndex)
> upperBounds = match(upperBounds, remainIndex)
> superset = superset[remainIndex]
>
>
> # Plant a subset sum:
> solution = integer(subsetSize)
> solution[1] = sample(lowerBounds[1] : upperBounds[1], 1)
> for(i in 2L : subsetSize)
+ {
+   l = max(lowerBounds[i], solution[i - 1] + 1L)
+   u = upperBounds[i]
+   if(l == u) solution[i] = u
+   else solution[i] = sample(l : u, 1)
+ }
> subsetSum = sum(superset[solution])
> subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
> rm(solution)
>
>
> rst3 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                     ME = subsetSumError, solutionNeed = 2, tlimit = 4,
+                     LB = lowerBounds, UB = upperBounds, viaConjugate = TRUE)
>
>
> print(length(rst3))
[1] 2
>
>
> # Verify solutions
> if(length(rst3) > 0)
+   cat(all(unlist(lapply(rst3, function(x)
+     abs(sum(superset[x]) - subsetSum) <= subsetSumError))), "\n")
TRUE
>
>
>
>
> # =====================================================================================
> # Example II: mine a real-world dataset.
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 401366 21.5     750400 40.1   515295 27.6
Vcells 837653  6.4    1650153 12.6  1308175 10.0
> superset = c(
+   -1119924501, -793412295, -496234747,  -213654767,   16818148,   26267601,   26557292,
+      27340260,   28343800,   32036573,    32847411,   34570996,   34574989,   43633028,
+      44003100,   47724096,   51905122,    52691025,   53600924,   56874435,   58207678,
+      60225777,   60639161,   60888288,    60890325,   61742932,   63780621,   63786876,
+      65167464,   66224357,   67198760,    69366452,   71163068,   72338751,   72960793,
+      73197629,   76148392,   77779087,    78308432,   81196763,   82741805,   85315243,
+      86446883,   87820032,   89819002,    90604146,   93761290,   97920291,   98315039,
+     310120088, -441403864, -548143111,  -645883459, -149110919,  305170449, -248934805,
+   -1108320430, -527806318, -192539936, -1005074405, -101557770, -156782742, -285384687,
+    -418917176,   80346546, -273215446,  -552291568,   86824498,  -95392618, -707778486)
> superset = sort(superset)
> subsetSum = 139254953
> subsetSumError = 0.1
>
>
> # Find a subset of size 10.
> subsetSize = 10L
> rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                    ME = subsetSumError, solutionNeed = 1, tlimit = 4)
> # Verify:
> all(unlist(lapply(rst, function(x)
+   abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
>
>
> # Find a subset without size specification.
> rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                    ME = subsetSumError, solutionNeed = 1, tlimit = 4)
> # Verify:
> all(unlist(lapply(rst, function(x)
+   abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
>
>
> # Find a subset via looping subset size over 2L : (length(v)).
> for(len in 2L : length(superset))
+ {
+   rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                      ME = subsetSumError, solutionNeed = 1, tlimit = 4)
+   if(length(rst) > 0) break
+ }
> # Verify:
> all(unlist(lapply(rst, function(x)
+   abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
>
>
> # Find as many qualified susbets as possible in 2 seconds
> rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                    ME = subsetSumError, solutionNeed = 999999L, tlimit = 2)
> cat("Number of solutions =", length(rst), "\n")
Number of solutions = 0
>
>
> # Verify:
> all(unlist(lapply(rst, function(x)
+   abs(sum(superset[x]) - subsetSum) <= subsetSumError)))
[1] TRUE
>
>
>
>
> # =====================================================================================
> # Example III: solve a special knapsack problem.
> # Given the knapsack's capacity, the number of catagories, the number of items in each
> # catagory, select the least number of items to fulfill at least 95% of the knapsack's
> # capacity.
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 401368 21.5     750400 40.1   515295 27.6
Vcells 837654  6.4    1650153 12.6  1308175 10.0
> capacity = 361
> catagories = LETTERS[1L : 10L] # A, B, ..., J, 10 catagories
> catagoryMasses = round(runif(length(catagories)) * 20 + 1)
> catagoryItems = sample(1L : 20L, length(catagories))
>
>
> itemLabel = unlist(mapply(function(x, i) rep(i, x), catagoryItems, catagories))
> itemMasses = unlist(mapply(function(x, i) rep(x, i), catagoryMasses, catagoryItems))
> vorder = order(itemMasses)
> itemLabel = itemLabel[vorder]
>
>
> superset = itemMasses[vorder]
> rate = 0.95
> subsetSum = (capacity * rate + capacity) / 2
> subsetSumError = capacity - subsetSum
> for(subsetSize in 1L : length(itemMasses))
+ {
+   rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
+                      ME = subsetSumError, solutionNeed = 1, tlimit = 4)
+   if(length(rst) > 0) break
+ }
>
>
> # There may exist no qualified subsets. One can lower 'rate' until a solution
> # shows up.
> if(length(rst) == 0L)
+ {
+   cat("No solutions. Please lower rate and rerun.\n")
+ } else
+ {
+   cat("A solution:\n")
+   print(table(itemLabel[rst[[1]]]))
+ }
A solution:

 A  B  C  H  I
 6  1  1  2 13
>
>
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 405798 21.7     750400 40.1   515295 27.6
Vcells 847271  6.5    1650153 12.6  1308175 10.0
>
>
>
> cleanEx()
> nameEx("FLSSSmultiset")
> ### * FLSSSmultiset
>
> flush(stderr()); flush(stdout())
>
> ### Name: FLSSSmultiset
> ### Title: Multi-Subset Sum given error threshold
> ### Aliases: FLSSSmultiset
>
> ### ** Examples
>
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 405798 21.7     750400 40.1   515295 27.6
Vcells 847271  6.5    1650153 12.6  1308175 10.0
> Nsupersets = 30L
> supersetSizes = sample(5L : 20L, Nsupersets, replace = TRUE)
> subsetSizes = sapply(supersetSizes, function(x) sample(1L : x, 1))
>
>
> # Create supersets at random:
> supersets = lapply(supersetSizes, function(n)
+ {
+   1000 * (rnorm(n) ^ 3 + 2 * runif(n) ^ 2 + 3 * rgamma(n, 5, 1) + 4)
+ })
> str(supersets) # see the structure
List of 30
 $ : num [1:9] 14813 15217 26299 24330 13801 ...
 $ : num [1:10] 29124 13322 15616 11712 20153 ...
 $ : num [1:14] 12974 31173 23070 24929 21448 ...
 $ : num [1:19] 29825 17356 12201 15426 23789 ...
 $ : num [1:8] 14831 11374 18373 20967 10989 ...
 $ : num [1:19] 15834 9864 35381 10936 35230 ...
 $ : num [1:20] 27320 13418 33020 18014 10939 ...
 $ : num [1:15] 26954 22381 19611 21574 13605 ...
 $ : num [1:15] 16591 13233 17734 23064 27096 ...
 $ : num [1:5] 14928 15658 15429 33567 15748
 $ : num [1:8] 32953 17942 18740 31193 17859 ...
 $ : num [1:7] 16215 13385 22768 31296 30566 ...
 $ : num [1:15] 14513 23077 15050 2047 16356 ...
 $ : num [1:11] 11103 24733 17963 18519 39474 ...
 $ : num [1:17] 8468 17723 28949 19197 14060 ...
 $ : num [1:12] 16275 30870 30217 19968 25153 ...
 $ : num [1:16] 29697 18606 36070 16360 18681 ...
 $ : num [1:20] 21395 7306 16699 14091 11874 ...
 $ : num [1:11] 26204 16280 27639 25503 21124 ...
 $ : num [1:17] 20761 20731 25559 15448 14512 ...
 $ : num [1:19] 13545 13397 22586 21711 26109 ...
 $ : num [1:8] 24989 25592 30520 37287 18835 ...
 $ : num [1:15] 27356 15847 5321 25069 19473 ...
 $ : num [1:7] 16376 22594 18978 24701 3115 ...
 $ : num [1:9] 13720 26752 33691 23917 9610 ...
 $ : num [1:11] 23343 14913 24452 20612 16566 ...
 $ : num [1:5] 10057 17796 -10423 13024 18944
 $ : num [1:11] 29544 10194 19627 16295 24605 ...
 $ : num [1:18] 32382 18426 23039 19465 18708 ...
 $ : num [1:10] 22546 22500 14208 18053 14336 ...
>
>
> # Give a subset sum
> solution = mapply(function(n, l) sample(1L : n, l), supersetSizes, subsetSizes)
> str(solution) # See structure
List of 30
 $ : int [1:5] 2 6 5 1 3
 $ : int [1:6] 10 2 5 7 3 6
 $ : int [1:7] 6 8 2 13 9 12 4
 $ : int [1:4] 3 13 9 4
 $ : int [1:7] 6 3 4 7 8 1 2
 $ : int [1:13] 4 13 5 2 11 15 3 18 16 19 ...
 $ : int [1:16] 1 17 9 20 6 16 4 3 14 12 ...
 $ : int [1:2] 1 15
 $ : int [1:11] 4 15 5 11 12 13 2 9 8 14 ...
 $ : int [1:3] 4 3 5
 $ : int [1:7] 8 5 1 6 2 3 4
 $ : int [1:5] 4 2 5 7 3
 $ : int [1:12] 10 1 2 12 15 5 8 13 3 4 ...
 $ : int [1:7] 4 6 8 11 3 10 1
 $ : int [1:10] 15 8 10 11 4 2 17 5 7 1
 $ : int [1:10] 5 7 4 12 10 8 3 2 6 1
 $ : int 14
 $ : int [1:10] 17 12 10 1 7 18 20 19 2 13
 $ : int [1:9] 9 1 4 7 10 3 2 6 5
 $ : int [1:12] 7 5 15 10 12 13 9 11 8 14 ...
 $ : int [1:10] 17 15 4 3 18 7 2 12 1 5
 $ : int [1:7] 4 3 5 2 7 8 6
 $ : int [1:7] 15 8 9 4 5 6 13
 $ : int [1:2] 7 2
 $ : int 4
 $ : int [1:2] 10 7
 $ : int [1:2] 2 3
 $ : int [1:6] 2 9 8 11 1 3
 $ : int [1:12] 7 11 9 6 5 8 1 14 3 2 ...
 $ : int [1:5] 10 8 1 4 9
> subsetsSum = sum(mapply(function(x, s) sum(x[s]), supersets, solution, SIMPLIFY = TRUE))
> subsetsSumError = abs(subsetsSum) * 1e-7 # relative error within 0.00001%
> rm(solution)
>
>
> # Mine subsets:
> rst = FLSSS::FLSSSmultiset(len = subsetSizes, buckets = supersets, target = subsetsSum,
+                            ME = subsetsSumError, solutionNeed = 3, tlimit = 4)
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x55F4ED7: __wcsnlen_avx2 (strlen-avx2.S:305)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C408: internal_utf8_loop (loop.c:298)
==3674==    by 0x548C408: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C411: internal_utf8_loop (loop.c:303)
==3674==    by 0x548C411: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x548C458: internal_utf8_loop (loop.c:298)
==3674==    by 0x548C458: __gconv_transform_internal_utf8 (skeleton.c:609)
==3674==    by 0x5522EF4: wcsrtombs (wcsrtombs.c:110)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
> cat("Number of solutions =", length(rst), "\n")
Number of solutions = 3
>
>
> # Verify:
> ver = all(unlist(lapply(rst, function(sol)
+ {
+   S = sum(unlist(mapply(function(x, y) sum(x[y]), supersets, sol)))
+   abs(S - subsetsSum) <= subsetsSumError
+ })))
> cat("All subsets are qualified:", ver)
All subsets are qualified: TRUE>
>
>
> cleanEx()
> nameEx("GAP")
> ### * GAP
>
> flush(stderr()); flush(stdout())
>
> ### Name: GAP
> ### Title: Generalized Assignment Problem solver
> ### Aliases: GAP
>
> ### ** Examples
>
> # =====================================================================================
> # Play random numbers
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 421689 22.6     750400 40.1   750400 40.1
Vcells 882434  6.8    1650153 12.6  1308175 10.0
> agents = 5L
> tasks = 12L
> costs = t(as.data.frame(lapply(1L : agents, function(x) runif(tasks) * 1000)))
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x55F4E97: __wcsnlen_avx2 (strlen-avx2.S:275)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x55F4EB7: __wcsnlen_avx2 (strlen-avx2.S:290)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
> budgets = apply(costs, 1, function(x) runif(1, min(x), sum(x)))
> profits = t(as.data.frame(lapply(1L : agents, function(x)
+   abs(rnorm(tasks) + runif(1, 0, 4)) * 10000)))
==3674== Conditional jump or move depends on uninitialised value(s)
==3674==    at 0x55F4E77: __wcsnlen_avx2 (strlen-avx2.S:261)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E3A1: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EE5176: ??? (in /usr/lib/R/lib/libR.so)
==3674==
>
>
> # A dirty function for examining the result's integrity. The function takes in
> # the task-agent assignment, the profit or cost matrix M, and calculates the cost
> # or profit generated by each agent. 'assignment' is a 2-column data
> # frame, first column task, second column agent.
> agentCostsOrProfits <- function(assignment, M)
+ {
+   n = ncol(M) * nrow(M)
+   M2 = matrix(numeric(n), ncol = tasks)
+   for(i in 1L : nrow(assignment))
+   {
+     x = as.integer(assignment[i, ])
+     M2[x[2], x[1]] = M[x[2], x[1]]
+   }
+   apply(M2, 1, function(x) sum(x))
+ }
>
>
> dimnames(costs) = NULL
> dimnames(profits) = NULL
> names(budgets) = NULL
>
>
>
>
> # =====================================================================================
> # Test case P03 from
> # https://people.sc.fsu.edu/~jburkardt/datasets/generalized_assignment/
> # =====================================================================================
> agents = 3L
> tasks = 8L
> profits = matrix(c(
+ 27, 12, 12, 16, 24, 31, 41, 13,
+ 14,  5, 37,  9, 36, 25,  1, 34,
+ 34, 34, 20,  9, 19, 19,  3, 34), ncol = tasks)
> costs = matrix(c(
+ 21, 13,  9,  5,  7, 15,  5, 24,
+ 20,  8, 18, 25,  6,  6,  9,  6,
+ 16, 16, 18, 24, 11, 11, 16, 18), ncol = tasks)
> budgets = c(26, 25, 34)
>
>
> rst = FLSSS::GAP(maxCore = 2L, agentsCosts = costs, agentsProfits = profits,
+                  agentsBudgets = budgets, heuristic = FALSE, tlimit = 2,
+                  useBiSrchInFB = FALSE, threadLoad = 8L, verbose = TRUE)
Mining starts..
Updated profit = 205
==3674== Invalid read of size 32
==3674==    at 0x55F4C91: __wcsnlen_avx2 (strlen-avx2.S:62)
==3674==    by 0x5522EC1: wcsrtombs (wcsrtombs.c:104)
==3674==    by 0x54A8B20: wcstombs (wcstombs.c:34)
==3674==    by 0x4EDACC2: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==  Address 0xadfeb10 is 0 bytes inside a block of size 20 alloc'd
==3674==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==3674==    by 0x4F7B1B0: R_chk_calloc (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4EDAC3D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F3EE4A: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4569D: ??? (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F4E1D7: Rf_eval (in /usr/lib/R/lib/libR.so)
==3674==    by 0x4F5066D: ??? (in /usr/lib/R/lib/libR.so)
==3674==
> agentCostsOrProfits(rst$assignedAgents, costs)
[1] 25 20 29
> # Should equal rst$assignmentCosts and not surpass budgets
>
>
> knownOptSolution = as.integer(c(3, 3, 1, 1, 2, 2, 1, 2))
> knownOptSolution = data.frame(task = 1L : tasks, agent = knownOptSolution)
>
>
> # Total profit from knownOptSolution:
> sum(agentCostsOrProfits(knownOptSolution, profits))
[1] 171
> # Total profit frim FLSSS::GAP():
> rst$assignmentProfit
[1] 205
> # FLSSS::GAP() generated a better solution.
>
>
>
> cleanEx()
> nameEx("GAPintegerized")
> ### * GAPintegerized
>
> flush(stderr()); flush(stdout())
>
> ### Name: GAPintegerized
> ### Title: An advanced version of 'GAP()'.
> ### Aliases: GAPintegerized
>
> ### ** Examples
>
> if(.Machine$sizeof.pointer == 8L){
+ # =====================================================================================
+ # 64-bit architecture required.
+ # =====================================================================================
+ # =====================================================================================
+ # Play random numbers
+ # =====================================================================================
+ rm(list = ls()); gc()
+ agents = 5L
+ tasks = 12L
+ costs = t(as.data.frame(lapply(1L : agents, function(x) runif(tasks) * 1000)))
+ budgets = apply(costs, 1, function(x) runif(1, min(x), sum(x)))
+ profits = t(as.data.frame(lapply(1L : agents, function(x)
+   abs(rnorm(tasks) + runif(1, 0, 4)) * 10000)))
+
+
+ # A dirty function for examining the result's integrity. The function takes in
+ # the task-agent assignment, the profit or cost matrix M, and calculates the cost
+ # or profit generated by each agent. 'assignment' is a 2-column data
+ # frame, first column task, second column agent.
+ agentCostsOrProfits <- function(assignment, M)
+ {
+   n = ncol(M) * nrow(M)
+   M2 = matrix(numeric(n), ncol = tasks)
+   for(i in 1L : nrow(assignment))
+   {
+     x = as.integer(assignment[i, ])
+     M2[x[2], x[1]] = M[x[2], x[1]]
+   }
+   apply(M2, 1, function(x) sum(x))
+ }
+
+
+ dimnames(costs) = NULL
+ dimnames(profits) = NULL
+ names(budgets) = NULL
+
+
+
+
+ # =====================================================================================
+ # Test case P03 from
+ # https://people.sc.fsu.edu/~jburkardt/datasets/generalized_assignment/
+ # =====================================================================================
+ agents = 3L
+ tasks = 8L
+ profits = matrix(c(
+ 27, 12, 12, 16, 24, 31, 41, 13,
+ 14,  5, 37,  9, 36, 25,  1, 34,
+ 34, 34, 20,  9, 19, 19,  3, 34), ncol = tasks)
+ costs = matrix(c(
+ 21, 13,  9,  5,  7, 15,  5, 24,
+ 20,  8, 18, 25,  6,  6,  9,  6,
+ 16, 16, 18, 24, 11, 11, 16, 18), ncol = tasks)
+ budgets = c(26, 25, 34)
+
+
+ rst = FLSSS::GAPintegerized(maxCore = 2L, agentsCosts = costs, agentsProfits = profits,
+                             agentsBudgets = budgets, heuristic = FALSE, tlimit = 2,
+                             useBiSrchInFB = FALSE, threadLoad = 8L, verbose = TRUE)
+ agentCostsOrProfits(rst$assignedAgents, costs)
+ # Should equal rst$assignmentCosts and not surpass budgets
+
+
+ knownOptSolution = as.integer(c(3, 3, 1, 1, 2, 2, 1, 2))
+ knownOptSolution = data.frame(task = 1L : tasks, agent = knownOptSolution)
+
+
+ # Total profit from knownOptSolution:
+ sum(agentCostsOrProfits(knownOptSolution, profits))
+ # Total profit frim FLSSS::GAP():
+ rst$assignmentProfit
+ # FLSSS::GAP() generated a better solution.
+ # =====================================================================================
+ # =====================================================================================
+ }
Dimensionality reduced from 4 to 1
Mining starts..
Updated profit = 205
[1] 205
>
>
>
> cleanEx()
> nameEx("mFLSSSpar")
> ### * mFLSSSpar
>
> flush(stderr()); flush(stdout())
>
> ### Name: mFLSSSpar
> ### Title: Multithreaded multidimensional Subset Sum given error thresholds
> ### Aliases: mFLSSSpar
>
> ### ** Examples
>
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 432189 23.1     750400 40.1   750400 40.1
Vcells 904750  7.0    1650153 12.6  1308175 10.0
> subsetSize = 7L
> supersetSize = 60L
> dimension = 5L # dimensionality
>
>
> # Create a supertset at random:
> N = supersetSize * dimension
> superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 +
+   3 * rgamma(N, 5, 1) + 4), ncol = dimension)
> rm(N)
>
>
> # Plant a subset sum:
> solution = sample(1L : supersetSize, subsetSize)
> subsetSum = colSums(superset[solution, ])
> subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
> rm(solution)
>
>
> # Mine subsets, dimensions fully bounded
> rst = FLSSS::mFLSSSpar(maxCore = 2, len = subsetSize, mV = superset,
+                        mTarget = subsetSum, mME = subsetSumError,
+                        solutionNeed = 2, dl = ncol(superset), du = ncol(superset),
+                        tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)
>
>
> # Verify:
> cat("Number of solutions = ", length(rst), "\n")
Number of solutions =  0
> if(length(rst) > 0)
+ {
+   cat("Solutions unique: ")
+   cat(length(unique(lapply(rst, function(x) sort(x)))) == length(rst), "\n")
+   cat("Solutions correct: ")
+   cat(all(unlist(lapply(rst, function(x)
+     abs(colSums(superset[x, ]) - subsetSum) <= subsetSumError))), "\n")
+ } else
+ {
+   cat("No solutions exist or timer ended too soon.\n")
+ }
No solutions exist or timer ended too soon.
>
>
>
>
> # Mine subsets, the first 3 dimensions lower bounded,
> # the last 4 dimension upper bounded
> rst = FLSSS::mFLSSSpar(maxCore = 2, len = subsetSize, mV = superset,
+                        mTarget = subsetSum, mME = subsetSumError,
+                        solutionNeed = 2, dl = 3L, du = 4L,
+                        tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)
>
>
> # Verify:
> cat("Number of solutions = ", length(rst), "\n")
Number of solutions =  2
> if(length(rst) > 0)
+ {
+   cat("Solutions unique: ")
+   cat(length(unique(lapply(rst, function(x) sort(x)))) == length(rst), "\n")
+   cat("Solutions correct: ")
+   cat(all(unlist(lapply(rst, function(x)
+   {
+     lowerBoundedDim = 1L : 3L
+     lowerBounded = all(colSums(superset[x, lowerBoundedDim]) >=
+       subsetSum[lowerBoundedDim] - subsetSumError[lowerBoundedDim])
+
+
+     upperBoundedDim = (ncol(superset) - 3L) : ncol(superset)
+     upperBounded = all(colSums(superset[x, upperBoundedDim]) <=
+       subsetSum[upperBoundedDim] + subsetSumError[upperBoundedDim])
+
+
+     lowerBounded & upperBounded
+   }))), "\n")
+ } else
+ {
+   cat("No solutions exist or timer ended too soon.\n")
+ }
Solutions unique: TRUE
Solutions correct: TRUE
>
>
>
> cleanEx()
> nameEx("mFLSSSparImposeBounds")
> ### * mFLSSSparImposeBounds
>
> flush(stderr()); flush(stdout())
>
> ### Name: mFLSSSparImposeBounds
> ### Title: Multithreaded multidimensional Subset Sum in bounded solution
> ###   space given error thresholds
> ### Aliases: mFLSSSparImposeBounds
>
> ### ** Examples
>
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 438194 23.5     750400 40.1   750400 40.1
Vcells 917463  7.0    1650153 12.6  1308175 10.0
> subsetSize = 7L
> supersetSize = 60L
> dimension = 5L # dimensionality
>
>
>
>
> cleanEx()
> nameEx("mFLSSSparImposeBoundsIntegerized")
> ### * mFLSSSparImposeBoundsIntegerized
>
> flush(stderr()); flush(stdout())
>
> ### Name: mFLSSSparImposeBoundsIntegerized
> ### Title: An advanced version of 'mFLSSSparImposeBounds()'
> ### Aliases: mFLSSSparImposeBoundsIntegerized
>
> ### ** Examples
>
> if(.Machine$sizeof.pointer == 8L){
+ # =====================================================================================
+ # 64-bit architecture required.
+ # =====================================================================================
+ rm(list = ls()); gc()
+ subsetSize = 7L
+ supersetSize = 60L
+ dimension = 5L # dimensionality
+
+ # =====================================================================================
+ # =====================================================================================
+ }
>
>
>
> cleanEx()
> nameEx("mFLSSSparIntegerized")
> ### * mFLSSSparIntegerized
>
> flush(stderr()); flush(stdout())
>
> ### Name: mFLSSSparIntegerized
> ### Title: An advanced version of 'mFLSSSpar()'
> ### Aliases: mFLSSSparIntegerized
>
> ### ** Examples
>
> if(.Machine$sizeof.pointer == 8L){
+ # =====================================================================================
+ # 64-bit architecture required.
+ # =====================================================================================
+ rm(list = ls()); gc()
+ subsetSize = 7L
+ supersetSize = 60L
+ dimension = 5L # dimensionality
+
+
+ # Create a supertset at random:
+ N = supersetSize * dimension
+ superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 + 3 * rgamma(N, 5, 1) + 4),
+                   ncol = dimension)
+ rm(N)
+
+
+ # Plant a subset sum:
+ solution = sample(1L : supersetSize, subsetSize)
+ subsetSum = colSums(superset[solution, ])
+ subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
+ rm(solution)
+
+
+ # Mine subsets, dimensions fully bounded
+ system.time({rst = FLSSS::mFLSSSparIntegerized(
+   maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
+   mME = subsetSumError, solutionNeed = 2, dl = ncol(superset),
+   du = ncol(superset), tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)})
+
+
+ # Compare the time cost of 'mFLSSSparIntegerized()' and 'mFLSSSpar()'. The
+ # speed advantage of 'mFLSSSparIntegerized()' may not be pronounced for toy
+ # examples.
+ system.time(FLSSS::mFLSSSpar(
+   maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
+   mME = subsetSumError, solutionNeed = 2, dl = ncol(superset),
+   du = ncol(superset), tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L))
+
+
+ # Verify:
+ cat("Number of solutions = ", length(rst$solution), "\n")
+ if(length(rst$solution) > 0)
+ {
+   cat("Solutions unique: ")
+   cat(length(unique(lapply(rst$solution, function(x)
+     sort(x)))) == length(rst$solution), "\n")
+
+
+   cat("Solutions correct regarding integerized data: ")
+   cat(all(unlist(lapply(rst$solution, function(x)
+     abs(colSums(rst$INT$mV[x, ]) - rst$INT$mTarget) <= rst$INT$mME))), "\n")
+
+
+   cat("Solutions correct regarding original data: ")
+   boolean = all(unlist(lapply(rst$solution, function(x)
+     abs(colSums(superset[x, ]) - subsetSum) <= subsetSumError)))
+   cat(boolean, "\n")
+   if(!boolean)
+   {
+     cat("The given error threshold relative to subset sum:\n")
+     givenRelaErr = round(abs(subsetSumError / subsetSum), 5)
+     cat(givenRelaErr, "\n")
+
+
+     cat("Solution subset sum relative error:\n")
+     tmp = lapply(rst$solution, function(x)
+     {
+       err = round(abs(colSums(superset[x, ]) / subsetSum -1), 5)
+       for(i in 1L : length(err))
+       {
+         if(givenRelaErr[i] < err[i]) message(paste0(err[i], " "), appendLF = FALSE)
+         else cat(err[i], "")
+       }
+       cat("\n")
+     })
+     cat("Integerization caused the errors. Future versions of")
+     cat("'mFLSSSparIntegerized()' would have a parameter of precision level.\n")
+   }
+ } else
+ {
+   cat("No solutions exist or time ended too soon.\n")
+ }
+
+
+ # Mine subsets, the first 3 dimensions lower bounded,
+ # the last 4 dimension upper bounded
+ rst = FLSSS::mFLSSSparIntegerized(
+   maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
+   mME = subsetSumError, solutionNeed = 2, dl = 3L, du = 4L, tlimit = 2,
+   useBiSrchInFB = FALSE, avgThreadLoad = 8L)
+
+
+ # Verify:
+ cat("Number of solutions = ", length(rst$solution), "\n")
+ if(length(rst$solution) > 0)
+ {
+   cat("Solutions unique: ")
+   cat(length(unique(lapply(rst$solution, function(x)
+     sort(x)))) == length(rst$solution), "\n")
+
+
+   cat("Solutions correct regarding integerized data: ")
+   cat(all(unlist(lapply(rst$solution, function(x)
+   {
+     lowerBoundedDim = 1L : 3L
+     lowerBounded = all(colSums(rst$INT$mV[x, lowerBoundedDim]) >=
+       rst$INT$mTarget[lowerBoundedDim] - rst$INT$mME[lowerBoundedDim])
+
+
+     upperBoundedDim = (ncol(rst$INT$mV) - 3L) : ncol(rst$INT$mV)
+     upperBounded = all(colSums(rst$INT$mV[x, upperBoundedDim]) <=
+       rst$INT$mTarget[upperBoundedDim] + rst$INT$mME[upperBoundedDim])
+
+
+     lowerBounded & upperBounded
+   }))), "\n")
+ } else
+ {
+   cat("No solutions exist or timer ended too soon.\n")
+ }
+ # =====================================================================================
+ # =====================================================================================
+ }
Dimensionality reduced from 6 to 2
Number of solutions =  2
Solutions unique: TRUE
Solutions correct regarding integerized data: TRUE
Solutions correct regarding original data: FALSE
The given error threshold relative to subset sum:
0.01 0.01 0.01 0.01 0.01
Solution subset sum relative error:
0.01013 0.00903 0.00531 0.0042 0.0061
0.00471 0.00554 0.00101 0.00882 0.00198
Integerization caused the errors. Future versions of'mFLSSSparIntegerized()' would have a parameter of precision level.
Dimensionality reduced from 6 to 2
Number of solutions =  2
Solutions unique: TRUE
Solutions correct regarding integerized data: TRUE
>
>
>
> cleanEx()
> nameEx("mmKnapsack")
> ### * mmKnapsack
>
> flush(stderr()); flush(stdout())
>
> ### Name: mmKnapsack
> ### Title: Multithreaded multidimensional Knapsack problem solver
> ### Aliases: mmKnapsack
>
> ### ** Examples
>
> # =====================================================================================
> # Play random numbers
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 446465 23.9     750400 40.1   750400 40.1
Vcells 934111  7.2    1650153 12.6  1308175 10.0
> subsetSize = 6
> supersetSize = 60
> NcostsAttr = 4
>
>
>
>
>
> # =====================================================================================
> # Test case P08 from
> # https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
> # =====================================================================================
> rm(list = ls()); gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 446468 23.9     750400 40.1   750400 40.1
Vcells 934113  7.2    1650153 12.6  1308175 10.0
> costs = matrix(c(382745, 799601, 909247, 729069, 467902,  44328,  34610, 698150,
+                  823460, 903959, 853665, 551830, 610856, 670702, 488960, 951111,
+                  323046, 446298, 931161,  31385, 496951, 264724, 224916, 169684),
+                ncol = 1)
>
>
> gains = c( 825594, 1677009, 1676628, 1523970,  943972,   97426,  69666, 1296457,
+           1679693, 1902996, 1844992, 1049289, 1252836, 1319836, 953277, 2067538,
+            675367,  853655, 1826027,   65731,  901489,  577243, 466257,  369261)
>
>
> budgets = 6404180
>
>
> # 'mmKnapsack()' is designed for the multidimensional Knapsack and may not
> # be ideal for one-dimensional 0-1 Knapsack regarding computing speed.
> # 'len = 0' causes substantial deceleration. Looping 'len' over possible
> # values is recommended if 'len' is ungiven.
> rst1 = FLSSS::mmKnapsack(
+   maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
+   capacities = budgets, heuristic = FALSE, tlimit = 2, threadLoad = 4L,
+   verbose = TRUE)
Updated profit = 1.34437e+07
Updated profit = 1.34972e+07
Updated profit = 1.35491e+07
> rst1 = sort(rst1)
>
>
> cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
Correct solution:
1 2 4 5 6 10 11 13 16 22 23 24
FLSSS solution =
> cat(rst1, "\n")
1 2 4 5 6 10 11 13 16 22 23 24
>
>
>
>
> # =====================================================================================
> # Test case P07 from
> # https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
> # =====================================================================================
> costs = matrix(c(70, 73, 77, 80, 82, 87, 90, 94, 98, 106, 110, 113, 115, 118, 120),
+                ncol = 1)
>
>
> gains = c(135, 139, 149, 150, 156, 163, 173, 184, 192, 201, 210, 214, 221, 229, 240)
>
>
> budgets = 750
>
>
> rst2 = FLSSS::mmKnapsack(
+   maxCore = 2L, len = 8L, itemsProfits = gains, itemsCosts = costs,
+   capacities = budgets, heuristic = FALSE, tlimit = 2,
+   threadLoad = 4L, verbose = TRUE)
Updated profit = 382
> rst2 = sort(rst2)
>
>
> cat("Correct solution:\n1 3 5 7 8 9 14 15\nFLSSS solution =\n")
Correct solution:
1 3 5 7 8 9 14 15
FLSSS solution =
> cat(rst2, "\n")
1 3 5 7 8 9 14 15
>
>
>
> cleanEx()
> nameEx("mmKnapsackIntegerized")
> ### * mmKnapsackIntegerized
>
> flush(stderr()); flush(stdout())
>
> ### Name: mmKnapsackIntegerized
> ### Title: An advanced version of 'mmKnapsack()'
> ### Aliases: mmKnapsackIntegerized
>
> ### ** Examples
>
> if(.Machine$sizeof.pointer == 8L){
+ # =====================================================================================
+ # 64-bit architecture required.
+ # =====================================================================================
+ # =====================================================================================
+ # Play random numbers
+ # =====================================================================================
+ rm(list = ls()); gc()
+ subsetSize = 6
+ supersetSize = 60
+ NcostsAttr = 4
+
+
+
+
+
+ # =====================================================================================
+ # Test case P08 from
+ # https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
+ # =====================================================================================
+ costs = matrix(c(382745, 799601, 909247, 729069, 467902,  44328,  34610, 698150,
+                  823460, 903959, 853665, 551830, 610856, 670702, 488960, 951111,
+                  323046, 446298, 931161,  31385, 496951, 264724, 224916, 169684),
+                ncol = 1)
+
+
+ gains = c( 825594, 1677009, 1676628, 1523970,  943972,   97426,  69666, 1296457,
+           1679693, 1902996, 1844992, 1049289, 1252836, 1319836, 953277, 2067538,
+            675367,  853655, 1826027,   65731,  901489,  577243, 466257,  369261)
+
+
+ budgets = 6404180
+
+
+ # 'mmKnapsackIntegerized()' is designed for the multidimensional Knapsack
+ # and may not be ideal for one-dimensional 0-1 Knapsack regarding computing speed.
+ # 'len = 0' would cause severe deceleration. Looping 'len' over possible
+ # values is recommended if 'len' is ungiven.
+ rst = FLSSS::mmKnapsackIntegerized(
+   maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
+   capacities = budgets, heuristic = FALSE, tlimit = 2, threadLoad = 4L, verbose = TRUE)
+ rst = sort(rst$solution)
+
+
+ cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
+ cat(rst, "\n")
+ # The difference is due to rounding errors in real-integer conversion. The default
+ # 'precisionLevel' shifts, scales and rounds 'itemCosts' such that its
+ # maximal element is no less than 8 times the number of items.
+
+
+ # Increase the precision level
+ rst = FLSSS::mmKnapsackIntegerized(
+   maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
+   capacities = budgets, heuristic = FALSE, precisionLevel = rep(500L, 1),
+   tlimit = 2, threadLoad = 4L, verbose = TRUE)
+ # 'precisionLevel = 500' shifts, scales and rounds 'itemCosts' such that its
+ # maximal element is no less than 500.
+ rst = sort(rst$solution)
+ cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
+ cat(rst, "\n")
+ }
Dimensionality reduced from 2 to 1
Updated profit = 1.34437e+07
Updated profit = 1.34972e+07
Updated profit = 1.35491e+07
Correct solution:
1 2 4 5 6 10 11 13 16 22 23 24
FLSSS solution =
1 2 4 5 6 10 11 13 16 22 23 24
Dimensionality reduced from 2 to 1
Updated profit = 1.34437e+07
Updated profit = 1.34972e+07
Updated profit = 1.35491e+07
Correct solution:
1 2 4 5 6 10 11 13 16 22 23 24
FLSSS solution =
1 2 4 5 6 10 11 13 16 22 23 24
> # =====================================================================================
> # =====================================================================================
>
>
>
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  310.143 18.098 317.31 0 0
> grDevices::dev.off()
null device
          1
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
==3674==
==3674== HEAP SUMMARY:
==3674==     in use at exit: 51,858,973 bytes in 25,106 blocks
==3674==   total heap usage: 38,153,968 allocs, 38,128,862 frees, 372,785,097 bytes allocated
==3674==
==3674== LEAK SUMMARY:
==3674==    definitely lost: 0 bytes in 0 blocks
==3674==    indirectly lost: 0 bytes in 0 blocks
==3674==      possibly lost: 2,128 bytes in 7 blocks
==3674==    still reachable: 51,856,845 bytes in 25,099 blocks
==3674==                       of which reachable via heuristic:
==3674==                         newarray           : 7,360 bytes in 4 blocks
==3674==         suppressed: 0 bytes in 0 blocks
==3674== Rerun with --leak-check=full to see details of leaked memory
==3674==
==3674== For counts of detected and suppressed errors, rerun with: -v
==3674== Use --track-origins=yes to see where uninitialised values come from
==3674== ERROR SUMMARY: 246281 errors from 16 contexts (suppressed: 0 from 0)
